# 拷贝控制

## 五种特殊的成员函数

### 拷贝构造函数

### 移动构造函数

### 拷贝赋值函数

### 移动赋值函数

### 析构函数

## 拷贝构造函数

### Foo(const Foo&)

### 不定义的话，会有个合成拷贝构造函数，会逐个的拷贝非static成员变量

### 拷贝初始化

- 用=定义变量时
- 将一个对象作为实参传递给一个非引用的形参
- 函数返回非引用对象
- 花括号初始化数组或者聚合类
- push_back

	- 而emplace_back是直接初始化

### 拷贝构造函数的参数必须是引用类型，一般是const。 而且一般不定义explict

## 拷贝赋值函数

### Foo& operator=(const Foo&)

### 不定义的话，会有个合成拷贝赋值函数，会逐个的赋值每个static成员变量

## 析构函数

### 函数体不负责成员析构，是先执行完函数体，之后在函数体外，隐式的按照成员出现的顺序逆序析构

## 三/五法则

### 好像没说什么

## 杂项

### =default，表明使用编译器合成的拷贝控制函数

### =delete，表示该函数是删除的，无法被访问

### 如果一个类有成员无法构造，复制，赋值，销毁，则对应的成员函数是删除的

### 赋值函数需要考虑自赋值的情况

### 交换操作可以节省资源，提升性能

### 区分移动和拷贝的重载函数版本通常有一个版本的参数是const&, 一个版本是&& 

## 对象移动

### 右值引用

- 通过&&获得
- 只能绑定到一个即将销毁的对象
- 右值引用可以绑定到表达式上，但是不能绑定到左值上
- 变量是左值，因此右值引用不能直接绑定到变量上，哪怕变量类型是右值引用也不行。这里还引申出一个概念，具名右值引用

	- 虽然不能绑定左值，但是可以使用move将左值转换成右值，move后变量处于销毁它是无害的一种状态，但此时不可以获取值了，未定义

- 移动右值，拷贝左值。但是如果没有定义移动函数，则右值也会被拷贝

### 移动构造函数

- 一般指定是noexpect，因为移动构造函数一般不涉及资源分配，这样基本不会抛出异常，所以需要显式告诉标准库，否则标准库会为了防止异常做一些额外工作，譬如vector的push_back，如果知道移动可能出现问题，则会调用拷贝构造而不是移动构造

### 移动赋值函数

- 同上，一般指定noexpect

### 合成移动函数

- 只有当一个类没有定义自己的拷贝控制函数，同时所有的非static成员都是可以移动时，类才会合成移动函数

### 移动迭代器

- make_move_iterator

### 引用限定符

- Foo& operator=(const Foo&) &

	- 表示this指针只能绑定左值引用

- 可以加上const限定符，不过必须放在引用限定符之后
- 如果有一个重载版本添加了引用限定符，则所有的重载版本都需要添加

*XMind - Trial Version*